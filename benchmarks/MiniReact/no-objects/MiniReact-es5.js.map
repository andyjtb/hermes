{"version":3,"names":["invariant$default","condition","format","Error","CHECKED_CAST$default","value","React$INTERNAL$queueMicrotask","callback","HermesInternal","enqueueJob","React$INTERNAL$fastArrayJoin","arr","sep","result","i","e","length","React$INTERNAL$React$Element","_createClass","type","props","key","ref","_classCallCheck","React$INTERNAL$workInProgressRoot","React$INTERNAL$workInProgressFiber","React$INTERNAL$workInProgressState","React$INTERNAL$renderPhaseUpdateQueue","React$createRoot","React$INTERNAL$Root","React$useState","initial","fiber","root","state","_workInProgressState","nextState","React$INTERNAL$State","next","updater","update","React$INTERNAL$Update","push","notify","run","fn","changed","Object","is","element","updateQueue","_this","doWork","render","hasChanges","output","printFiber","mustRender","mountFiber","fiber2","renderFiber","child","sibling","parent","out","kind","tag","prop","entries","_JSON$stringify","JSON","stringify","printChildren","text","current","component","iterationCount","reconcileFiber","elementOrString","React$INTERNAL$FiberTypeComponent","React$INTERNAL$Fiber","React$INTERNAL$FiberTypeHost","children","assign","Array","isArray","prev","childElement","React$INTERNAL$FiberTypeText","prevChild","reconcileChildren","childrenArray","reconcileMultipleChildren","keyedChildren","Map","set","prevByIndex","_ref","prevFiber","get","React$INTERNAL$FiberType","_React$INTERNAL$Fiber","_inherits","_super","_createSuper","_this2","call","_React$INTERNAL$Fiber2","_super2","_this3","_React$INTERNAL$Fiber3","_super3","_this4","React$createElement","index$INTERNAL$Title","index$INTERNAL$MyComponent","_props","_React$useState","_React$useState2","_slicedToArray","count","setCount","index$INTERNAL$run","N","rendered","print"],"sources":["benchmarks/MiniReact/no-objects/src/invariant.js","benchmarks/MiniReact/no-objects/src/CHECKED_CAST.js","benchmarks/MiniReact/no-objects/src/React.js","benchmarks/MiniReact/no-objects/src/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nexport default function invariant(condition: boolean, format: string): void {\n  'inline';\n\n  if (!condition) {\n    throw new Error(format);\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nexport default function CHECKED_CAST<T>(value: mixed): T {\n  'inline';\n  return (value: any);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport invariant from './invariant';\nimport CHECKED_CAST from './CHECKED_CAST';\n\nfunction queueMicrotask(callback: () => void) {\n  HermesInternal.enqueueJob(callback);\n}\n\nfunction fastArrayJoin(arr: string[], sep: string): string {\n  let result: string = '';\n  for (let i: number = 0, e = arr.length; i < e; ++i) {\n    if (i !== 0) result += sep;\n    result += arr[i];\n  }\n  return result;\n}\n\nexport type React$Node = string | React$Element<React$ElementType>;\n\n/**\n * The type of an element in React. A React element may be a:\n *\n * - String. These elements are intrinsics that depend on the React renderer\n *   implementation.\n * - React component. See `ComponentType` for more information about its\n *   different variants.\n */\ntype React$ElementType =\n  | string\n  | Component /* TODO: React$AbstractComponent<empty, mixed> */;\n\n/**\n * Type of a React element. React elements are commonly created using JSX\n * literals, which desugar to React.createElement calls (see below).\n */\n// type React$Element<ElementType: React$ElementType> = {|\n//   type: ElementType,\n//   props: Props,\n//   key: React$Key | null,\n//   ref: any,\n// |};\nclass React$Element<ElementType> {\n  type: ElementType;\n  props: Props;\n  key: React$Key | null;\n  ref: any;\n\n  constructor(\n    type: ElementType,\n    props: Props,\n    key: React$Key | null,\n    ref: any,\n  ) {\n    this.type = type;\n    this.props = props;\n    this.key = key;\n    this.ref = ref;\n  }\n}\n\nexport type React$MixedElement = React$Element<React$ElementType>;\n\n/**\n * The type of the key that React uses to determine where items in a new list\n * have moved.\n */\ntype React$Key = string | number;\n\n/* eslint-disable lint/strictly-null, lint/react-state-props-mutation, lint/flow-react-element */\n\n/**\n * The current root\n */\nlet workInProgressRoot: Root | null = null;\n\n/**\n * The currently rendering fiber. Only set when a component is being rendered.\n */\nlet workInProgressFiber: Fiber | null = null;\n\n/**\n * The previous state hook, or null if no state hook has been evaluated yet.\n */\nlet workInProgressState: State<mixed> | null = null;\n\n/**\n * Queue of updates triggered *during* render.\n */\nconst renderPhaseUpdateQueue: Update<mixed>[] = [];\n\n/**\n * Public API to create a new \"root\", this is where React attaches rendering to a host element.\n * In our case we don't actually have a real host, and currently only \"render\" to strings.\n */\nexport function createRoot(): Root {\n  return new Root();\n}\n\n/**\n * Hook to create (on initial render) or access (on update) a state, using the index of the useState\n * call within the component as the identity. Thus conditionally calling this API can cause state to\n * be lost.\n */\nexport function useState<T>(\n  /**\n   * Initial value of the state\n   */\n  initial: T,\n): [T, (value: T | ((prev: T) => T)) => void] {\n  invariant(\n    fiber !== null && root !== null,\n    'useState() called outside of render',\n  );\n  const root: Root = CHECKED_CAST<Root>(workInProgressRoot);\n  const fiber: Fiber = CHECKED_CAST<Fiber>(workInProgressFiber);\n\n  let state: State<T>;\n  const _workInProgressState: State<mixed> | null = workInProgressState;\n  if (_workInProgressState === null) {\n    // Get or initialize the first state on the fiber\n    let nextState = fiber.state;\n    if (nextState === null) {\n      nextState = new State<mixed>(initial);\n      fiber.state = nextState;\n    }\n    // NOTE: in case of a re-render we assume that the hook types match but\n    // can't statically prove this\n    state = CHECKED_CAST<State<T>>(nextState);\n  } else {\n    let nextState = CHECKED_CAST<State<mixed>>(_workInProgressState).next;\n    if (nextState === null) {\n      nextState = new State<mixed>(initial);\n      CHECKED_CAST<State<mixed>>(_workInProgressState).next = nextState;\n    }\n    // NOTE: in case of a re-render we assume that the hook types match but\n    // can't statically prove this\n    state = CHECKED_CAST<State<T>>(nextState);\n  }\n  // NOTE: this should just work because of subtying, State<T> should be subtype of State<mixed>\n  workInProgressState = CHECKED_CAST<State<mixed>>(state);\n  return [\n    // Untyped check that the existing state value has the correct type,\n    // This is safe if components follow the rules of hooks\n    CHECKED_CAST<T>(state.value),\n    (updater: T | ((prev: T) => T)): void => {\n      const update = new Update<mixed>(\n        fiber,\n        CHECKED_CAST<State<mixed>>(state),\n        CHECKED_CAST<T | ((prev: T) => T)>(updater),\n      );\n      if (workInProgressFiber !== null) {\n        // called during render\n        renderPhaseUpdateQueue.push(update);\n      } else {\n        root.notify(update);\n      }\n    },\n  ];\n}\n\n/**\n * The type of value that may be passed to the setState function (second part of useState return value).\n * - T: the new value\n * - (prev: T) => T: a function to compute the new value from the old value\n */\n// type Updater<T> = T | ((prev: T) => T);\n\n/**\n * The type of the setState function (second element of the array returned by useState).\n */\n// type SetState<T> = (value: Updater<T>) => void;\n\n/**\n * A queued state update.\n */\nclass Update<T> {\n  fiber: Fiber; // used to check state updates that occur during render to see if they came from the current component.\n  state: State<T>;\n  updater: T | ((prev: T) => T); // Updater<T>;\n\n  constructor(fiber: Fiber, state: State<T>, updater: T | ((prev: T) => T)) {\n    this.fiber = fiber;\n    this.state = state;\n    this.updater = updater;\n  }\n\n  /**\n   * Process the state update\n   */\n  run(): boolean {\n    const state = this.state;\n    let value: T = state.value;\n    const updater = this.updater;\n    if (typeof updater === 'function') {\n      // NOTE: The type of Updater<T> is meant to expresss `T (not function) | T (function of T => T)`\n      // thus the fact that updater is a function here menas its a function of T => T.\n      const fn = CHECKED_CAST<(prev: T) => T>(updater);\n      value = fn(state.value);\n    } else {\n      // NOTE: The type of Updater<T> is meant to expresss `T (not function) | T (function of T => T)`\n      // thus the fact that updater is *not* a function here means it is a T\n      value = CHECKED_CAST<T>(updater);\n    }\n    const changed = !Object.is(state.value, value);\n    state.value = value;\n    return changed;\n  }\n}\n\nclass Root {\n  /**\n   * The fiber representing the root node (`element`), null until\n   * render is first called.\n   */\n  root: Fiber | null;\n\n  /**\n   * The last rendered root element, initially null.\n   */\n  element: React$MixedElement | null;\n\n  /**\n   * Queue of updates (state changes) to apply on the next render\n   */\n  updateQueue: Update<mixed>[];\n\n  constructor() {\n    this.root = null;\n    this.element = null;\n    this.updateQueue = ([]: Update<mixed>[]);\n  }\n\n  /**\n   * Notify the root that an update is scheduled\n   */\n  notify(update: Update<mixed>): void {\n    this.updateQueue.push(update);\n    if (this.updateQueue.length === 1) {\n      queueMicrotask((): void => {\n        const element = this.element;\n        invariant(\n          element !== null,\n          'Expected an element to be set after rendering',\n        );\n        this.doWork(CHECKED_CAST<React$MixedElement>(element));\n      });\n    }\n  }\n\n  /**\n   * Drive any remaining work to completion and return the rendered result\n   */\n  render(element: React$MixedElement): string {\n    invariant(\n      workInProgressFiber === null && workInProgressState === null,\n      'Cannot render, an existing render is in progress',\n    );\n    const hasChanges = element !== this.element;\n    this.element = element;\n    if (hasChanges) {\n      this.doWork(element);\n    }\n\n    invariant(this.root !== null, 'Expected root to be rendered');\n    const root: Fiber = CHECKED_CAST<Fiber>(this.root);\n    const output: string[] = [];\n    this.printFiber(root, output);\n    // return output.join('');\n    return fastArrayJoin(output, '');\n  }\n\n  doWork(element: React$MixedElement): void {\n    let mustRender = this.root === null;\n    for (const update of this.updateQueue) {\n      mustRender = update.run() || mustRender;\n    }\n    this.updateQueue = ([]: Update<mixed>[]);\n    if (!mustRender) {\n      return;\n    }\n\n    // Visit the tree in pre-order, rendering each node\n    // and then processing its children\n    // eslint-disable-next-line consistent-this\n    workInProgressRoot = this;\n    let fiber = this.root;\n    if (fiber === null) {\n      fiber = this.mountFiber(element, null);\n      this.root = fiber;\n    }\n    while (fiber !== null) {\n      // Render the fiber, which creates child/sibling nodes\n      let fiber2: Fiber = CHECKED_CAST<Fiber>(fiber);\n      this.renderFiber(fiber2);\n      // advance to the next fiber\n      if (fiber2.child !== null) {\n        fiber = fiber2.child;\n      } else if (fiber2.sibling !== null) {\n        fiber = fiber2.sibling;\n      } else {\n        fiber = fiber2.parent;\n        while (fiber !== null && CHECKED_CAST<Fiber>(fiber).sibling === null) {\n          fiber = CHECKED_CAST<Fiber>(fiber).parent;\n        }\n        if (fiber !== null) {\n          fiber = CHECKED_CAST<Fiber>(fiber).sibling;\n        }\n      }\n    }\n    workInProgressRoot = null;\n  }\n\n  /**\n   * Prints a representation of the output DOM as HTML, emitting HTML snippets to @param out.\n   */\n  printFiber(fiber: Fiber, out: string[]): void {\n    switch (fiber.type.kind) {\n      case 'host': {\n        const tag = CHECKED_CAST<FiberTypeHost>(fiber.type).tag;\n        out.push('<' + tag);\n        for (const prop of Object.entries(fiber.props)) {\n          out.push(\n            ` ${prop.prop}=${JSON.stringify(prop.value) ?? 'undefined'}`,\n          );\n        }\n        out.push('>');\n        this.printChildren(fiber, out);\n        out.push('</' + tag + '>');\n        break;\n      }\n      case 'text': {\n        const text = CHECKED_CAST<FiberTypeText>(fiber.type).text;\n        out.push(text);\n        break;\n      }\n      case 'component': {\n        this.printChildren(fiber, out);\n        break;\n      }\n    }\n  }\n\n  printChildren(fiber: Fiber, out: string[]): void {\n    let current: Fiber | null = fiber.child;\n    while (current !== null) {\n      this.printFiber(CHECKED_CAST<Fiber>(current), out);\n      current = CHECKED_CAST<Fiber>(current).sibling;\n    }\n  }\n\n  /**\n   * Renders and reconciles the output of the given @param fiber. Note that this does not *render*\n   * children, it only reconciles the current output of the fiber with the previous children.\n   */\n  renderFiber(fiber: Fiber): void {\n    try {\n      workInProgressFiber = fiber;\n      workInProgressState = null;\n      switch (fiber.type.kind) {\n        case 'component': {\n          invariant(\n            renderPhaseUpdateQueue.length === 0,\n            'Expected no queued render updates',\n          );\n          const render: (props: Props) => React$MixedElement =\n            CHECKED_CAST<FiberTypeComponent>(fiber.type).component;\n          let element = render(fiber.props);\n          let iterationCount: number = 0;\n          while (renderPhaseUpdateQueue.length !== 0) {\n            iterationCount++;\n            invariant(\n              iterationCount < 1000,\n              'Possible infinite loop with setState during render',\n            );\n            let hasChanges = false;\n            for (const update of renderPhaseUpdateQueue) {\n              invariant(\n                update.fiber === fiber,\n                'setState() during render is currently only supported when updating the component ' +\n                  'being rendered. Setting state from another component is not supported.',\n              );\n              hasChanges = update.run() || hasChanges;\n            }\n            renderPhaseUpdateQueue.length = 0;\n            if (!hasChanges) {\n              break;\n            }\n            element = render(fiber.props);\n          }\n          fiber.child = this.reconcileFiber(fiber, fiber.child, element);\n          break;\n        }\n        case 'host':\n        case 'text': {\n          // Nothing to reconcile, these nodes are visited by the main doWork() loop\n          break;\n        }\n      }\n    } finally {\n      workInProgressFiber = null;\n      workInProgressState = null;\n    }\n  }\n\n  /**\n   * Create a new fiber for the given element. Used when there is no fiber at\n   * a given tree position which can be reused.\n   */\n  mountFiber(elementOrString: React$Node, parent: Fiber | null): Fiber {\n    let fiber: Fiber;\n    if (typeof elementOrString === 'object') {\n      const element = CHECKED_CAST<React$MixedElement>(elementOrString);\n      if (typeof element.type === 'function') {\n        const component: Component = CHECKED_CAST<Component>(element.type);\n        // const type: FiberType = {\n        //   kind: 'component',\n        //   component,\n        // };\n        const type: FiberType = new FiberTypeComponent(component);\n        fiber = new Fiber(type, (element.props: any), element.key);\n      } else {\n        invariant(\n          typeof element.type === 'string',\n          'Expected a host component name such as \"div\" or \"span\", got ' +\n            CHECKED_CAST<string>(element.type),\n        );\n        // const type: FiberType = {\n        //   kind: 'host',\n        //   tag: element.type,\n        // };\n        const type: FiberType = new FiberTypeHost(\n          CHECKED_CAST<string>(element.type),\n        );\n        invariant(\n          element.props !== null && typeof element.props === 'object',\n          'Expected component props',\n        );\n\n        // const {children, ...props} = element.props;\n        const children = element.props.children;\n        const props = {...element.props};\n        delete props.children;\n\n        fiber = new Fiber(type, props, element.key);\n        if (Array.isArray(children)) {\n          let prev: Fiber | null = null;\n          for (const childElement of CHECKED_CAST<any[]>(children)) {\n            const child = this.mountFiber(\n              CHECKED_CAST<React$Node>(childElement),\n              fiber,\n            );\n            if (prev !== null) {\n              CHECKED_CAST<Fiber>(prev).sibling = child;\n            } else {\n              // set parent to point to first child\n              fiber.child = child;\n            }\n            prev = child;\n          }\n        } else if (typeof children === 'string') {\n          const child = new Fiber({kind: 'text', text: children}, {}, null);\n          child.parent = fiber;\n          fiber.child = child;\n        } else if (children != null) {\n          const child = this.mountFiber((children: any), fiber);\n          fiber.child = child;\n        }\n      }\n    } else {\n      invariant(typeof elementOrString === 'string', 'Expected a string');\n      // const type: FiberType = {\n      //   kind: 'text',\n      //   text: element,\n      // };\n      const type = new FiberTypeText(CHECKED_CAST<string>(elementOrString));\n      fiber = new Fiber(type, {}, null);\n    }\n    fiber.parent = parent;\n    return fiber;\n  }\n\n  /**\n   * Update's @param parent's child to reflect the latest desired output as described by @param element.\n   * This either reuses @param prevChild if present and the component type matches, otherwise it creates\n   * a new Fiber.\n   */\n  reconcileFiber(\n    parent: Fiber,\n    prevChild: Fiber | null,\n    element: React$MixedElement,\n  ): Fiber {\n    if (\n      prevChild !== null &&\n      CHECKED_CAST<Fiber>(prevChild).type === element.type\n    ) {\n      let prevChild: Fiber = CHECKED_CAST<Fiber>(prevChild);\n      // Only host nodes have to be reconciled: otherwise this is a function component\n      // and its children will be reconciled when they are later emitted in a host\n      // position (ie as a direct result of render)\n      if (prevChild.type.kind === 'host') {\n        invariant(\n          element.props !== null && typeof element.props === 'object',\n          'Expected component props',\n        );\n\n        // const {children, ...props} = element.props;\n        const children = element.props.children;\n        const props = {...element.props};\n        delete props.children;\n\n        prevChild.props = props;\n        this.reconcileChildren(prevChild, (children: any));\n      } else if (prevChild.type.kind === 'component') {\n        invariant(\n          element.props !== null && typeof element.props === 'object',\n          'Expected component props',\n        );\n        prevChild.props = element.props;\n      }\n      return prevChild;\n    } else {\n      const child = this.mountFiber(element, parent);\n      return child;\n    }\n  }\n\n  /**\n   * Reconciles the @param parent fiber's children nodes.\n   */\n  reconcileChildren(\n    parent: Fiber,\n    children: React$MixedElement[] | React$MixedElement | string | null | void,\n  ): void {\n    const prevChild: Fiber | null = parent.child;\n    if (Array.isArray(children)) {\n      let childrenArray = CHECKED_CAST<React$MixedElement[]>(children);\n      // Fast-path for empty and single-element arrays\n      if (childrenArray.length === 0) {\n        parent.child = null;\n      } else if (childrenArray.length === 1) {\n        parent.child = this.reconcileFiber(parent, prevChild, childrenArray[0]);\n        CHECKED_CAST<Fiber>(parent.child).sibling = null;\n      } else {\n        this.reconcileMultipleChildren(parent, childrenArray);\n      }\n    } else if (typeof children === 'string') {\n      if (\n        prevChild === null ||\n        CHECKED_CAST<Fiber>(prevChild).type.kind !== 'text'\n      ) {\n        const child = new Fiber({kind: 'text', text: children}, {}, null);\n        parent.child = child;\n      } else {\n        CHECKED_CAST<FiberTypeText>(CHECKED_CAST<Fiber>(prevChild).type).text =\n          CHECKED_CAST<string>(children);\n      }\n    } else if (children != null) {\n      parent.child = this.reconcileFiber(\n        parent,\n        prevChild,\n        CHECKED_CAST<React$MixedElement>(children),\n      );\n      CHECKED_CAST<Fiber>(parent.child).sibling = null;\n    } else {\n      parent.child = null;\n      if (prevChild !== null) {\n        CHECKED_CAST<Fiber>(prevChild).parent = null;\n      }\n    }\n  }\n\n  /**\n   * Reconciles the @param parent fiber's children when the children are known to\n   * have 2+ items. Note that the algorithm works for 0+ elements but a fast-path\n   * should be used for 0/1 item cases.\n   */\n  reconcileMultipleChildren(\n    parent: Fiber,\n    children: React$MixedElement[],\n  ): void {\n    invariant(\n      children.length > 1,\n      'Expected children to have multiple elements',\n    );\n    // map existing children by key to make subsequent lookup O(log n)\n    const keyedChildren: any = new Map();\n    let current: Fiber | null = parent.child;\n    while (current !== null) {\n      if (CHECKED_CAST<Fiber>(current).key !== null) {\n        keyedChildren.set(CHECKED_CAST<Fiber>(current).key, current);\n      }\n      current = CHECKED_CAST<Fiber>(current).sibling;\n    }\n    let prev: Fiber | null = null; // previous fiber at this key/index\n    let prevByIndex: Fiber | null = parent.child; // keep track of prev fiber at this index\n    for (const childElement of children) {\n      const prevFiber =\n        (childElement.key != null\n          ? keyedChildren.get(childElement.key)\n          : null) ?? prevByIndex;\n      let child: Fiber;\n      if (prevFiber != null) {\n        child = this.reconcileFiber(parent, prevFiber, childElement);\n      } else {\n        child = this.mountFiber(childElement, parent);\n      }\n      if (prev !== null) {\n        CHECKED_CAST<Fiber>(prev).sibling = child;\n      } else {\n        // set parent to point to first child\n        parent.child = child;\n      }\n      prev = child;\n      prevByIndex =\n        prevByIndex !== null ? CHECKED_CAST<Fiber>(prevByIndex).sibling : null;\n    }\n  }\n}\n\n/**\n * Describes the `type` field of Fiber, which can hold different data depending on the fiber's kind:\n * - Component stores a function of props => element.\n * - Host stores the name of the host component, ie \"div\"\n * - Text stores the text itself.\n */\ntype Component = (props: Props) => React$MixedElement;\n\n// type FiberType =\n//   | {\n//       kind: 'component',\n//       component: Component,\n//     }\n//   | {\n//       kind: 'host',\n//       tag: string,\n//     }\n//   | {\n//       kind: 'text',\n//       text: string,\n//     };\n\nclass FiberType {\n  kind: string;\n  constructor(kind: string) {\n    this.kind = kind;\n  }\n}\n\nclass FiberTypeComponent extends FiberType {\n  component: Component;\n  constructor(component: Component) {\n    super('component');\n    this.component = component;\n  }\n}\nclass FiberTypeHost extends FiberType {\n  tag: string;\n  constructor(tag: string) {\n    super('host');\n    this.tag = tag;\n  }\n}\nclass FiberTypeText extends FiberType {\n  text: string;\n  constructor(text: string) {\n    super('text');\n    this.text = text;\n  }\n}\n\n/**\n * The type of component props as seen by the framework, because processing is heterogenous\n * the framework only looks at the identity of prop values and does not otherwise make any\n * assumptions about which props may exist and what their types are.\n */\nexport type Props = any;\n\n/**\n * Data storage for the useState() hook\n */\nclass State<T> {\n  value: T;\n  next: State<T> | null;\n  prev: State<T> | null;\n\n  constructor(value: T) {\n    this.value = value;\n\n    this.next = null;\n    this.prev = null;\n  }\n}\n\n/**\n * Represents a node in the UI tree, and may correspond to a user-defined function component,\n * a host node, or a text node.\n */\nclass Fiber {\n  type: FiberType;\n  props: Props;\n  parent: Fiber | null;\n  child: Fiber | null;\n  sibling: Fiber | null;\n  state: State<mixed> | null;\n  key: React$Key | null;\n\n  constructor(type: FiberType, props: Props, key: React$Key | null) {\n    this.type = type;\n    this.props = props;\n    this.key = key;\n\n    this.parent = null;\n    this.child = null;\n    this.sibling = null;\n    this.state = null;\n  }\n}\n\nexport function createElement(\n  type: React$ElementType,\n  props: Props,\n  key: React$Key | null,\n): React$MixedElement {\n  'inline';\n  return {\n    type: type,\n    props: props,\n    key: key,\n    ref: null,\n  };\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {Props, React$MixedElement} from './React';\n\nimport * as React from './React';\n\nfunction Title(props: Props): React$MixedElement {\n  return React.createElement(\n    'h1',\n    {\n      children: props.children,\n    },\n    null,\n  );\n}\n\nfunction MyComponent(_props: Props): React$MixedElement {\n  const [count, setCount] = React.useState<number>(0);\n\n  return React.createElement(\n    'div',\n    {\n      children: [\n        React.createElement(\n          Title,\n          {\n            children: 'Hello',\n          },\n          null,\n        ),\n        ' world!',\n      ],\n    },\n    null,\n  );\n}\n\nfunction run(): void {\n  var N = 1;\n  for (var i = 0; i < N; ++i) {\n    var root = React.createRoot();\n    var rendered = root.render(React.createElement(MyComponent, {}, null));\n  }\n  print(rendered);\n}\n\nrun();\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUe,SAASA,iBAASA,CAACC,SAAkB,EAAEC,MAAc,EAAQ;EAC1E,QAAQ;;EAER,IAAI,CAACD,SAAS,EAAE;IACd,MAAM,IAAIE,KAAK,CAACD,MAAM,CAAC;EACzB;AACF;AAAC;ACNc,SAASE,oBAAYA,CAAIC,KAAY,EAAK;EACvD,QAAQ;;EACR,OAAQA,KAAK;AACf;AAAC;ACAD,SAASC,6BAAcA,CAACC,QAAoB,EAAE;EAC5CC,cAAc,CAACC,UAAU,CAACF,QAAQ,CAAC;AACrC;AAEA,SAASG,4BAAaA,CAACC,GAAa,EAAEC,GAAW,EAAU;EACzD,IAAIC,MAAc,GAAG,EAAE;EACvB,KAAK,IAAIC,CAAS,GAAG,CAAC,EAAEC,CAAC,GAAGJ,GAAG,CAACK,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAE,EAAED,CAAC,EAAE;IAClD,IAAIA,CAAC,KAAK,CAAC,EAAED,MAAM,IAAID,GAAG;IAC1BC,MAAM,IAAIF,GAAG,CAACG,CAAC,CAAC;EAClB;EACA,OAAOD,MAAM;AACf;;;;;;;;;;;;;;;;;;;;IA0BMI,4BAAa,gBAAAC,YAAA,CAMjB,SAAAD,6BACEE,IAAiB,EACjBC,KAAY,EACZC,GAAqB,EACrBC,GAAQ,EACR;EAAA;;EAAAC,eAAA,OAAAN,4BAAA;EACA,IAAI,CAACE,IAAI,GAAGA,IAAI;EAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;EAClB,IAAI,CAACC,GAAG,GAAGA,GAAG;EACd,IAAI,CAACC,GAAG,GAAGA,GAAG;AAChB,CAAC;;;;;;;;;;AAgBH,IAAIE,iCAA+B,GAAG,IAAI;;;;AAK1C,IAAIC,kCAAiC,GAAG,IAAI;;;;AAK5C,IAAIC,kCAAwC,GAAG,IAAI;;;;AAKnD,IAAMC,qCAAuC,GAAG,EAAE;;;;;AAM3C,SAASC,gBAAUA,CAAA,EAAS;EACjC,OAAO,IAAIC,mBAAI,CAAC,CAAC;AACnB;;;;;;AAOO,SAASC,cAAQA;;;;AAItBC,OAAU,EACkC;EAC5C/B,iBAAS,CACPgC,KAAK,KAAK,IAAI,IAAIC,IAAI,KAAK,IAAI,EAC/B,qCACF,CAAC;EACD,IAAMA,IAAU,GAAG7B,oBAAY,CAAOoB,iCAAkB,CAAC;EACzD,IAAMQ,KAAY,GAAG5B,oBAAY,CAAQqB,kCAAmB,CAAC;EAE7D,IAAIS,KAAe;EACnB,IAAMC,oBAAyC,GAAGT,kCAAmB;EACrE,IAAIS,oBAAoB,KAAK,IAAI,EAAE;;IAEjC,IAAIC,SAAS,GAAGJ,KAAK,CAACE,KAAK;IAC3B,IAAIE,SAAS,KAAK,IAAI,EAAE;MACtBA,SAAS,GAAG,IAAIC,oBAAK,CAAQN,OAAO,CAAC;MACrCC,KAAK,CAACE,KAAK,GAAGE,SAAS;IACzB;;;IAGAF,KAAK,GAAG9B,oBAAY,CAAWgC,SAAS,CAAC;EAC3C,CAAC,MAAM;IACL,IAAIA,UAAS,GAAGhC,oBAAY,CAAe+B,oBAAoB,CAAC,CAACG,IAAI;IACrE,IAAIF,UAAS,KAAK,IAAI,EAAE;MACtBA,UAAS,GAAG,IAAIC,oBAAK,CAAQN,OAAO,CAAC;MACrC3B,oBAAY,CAAe+B,oBAAoB,CAAC,CAACG,IAAI,GAAGF,UAAS;IACnE;;;IAGAF,KAAK,GAAG9B,oBAAY,CAAWgC,UAAS,CAAC;EAC3C;;EAEAV,kCAAmB,GAAGtB,oBAAY,CAAe8B,KAAK,CAAC;EACvD,OAAO;;;EAGL9B,oBAAY,CAAI8B,KAAK,CAAC7B,KAAK,CAAC,EAC5B,UAACkC,OAA6B,EAAW;IACvC,IAAMC,MAAM,GAAG,IAAIC,qBAAM,CACvBT,KAAK,EACL5B,oBAAY,CAAe8B,KAAK,CAAC,EACjC9B,oBAAY,CAAuBmC,OAAO,CAC5C,CAAC;IACD,IAAId,kCAAmB,KAAK,IAAI,EAAE;;MAEhCE,qCAAsB,CAACe,IAAI,CAACF,MAAM,CAAC;IACrC,CAAC,MAAM;MACLP,IAAI,CAACU,MAAM,CAACH,MAAM,CAAC;IACrB;EACF,CAAC,CACF;AACH;;;;;;;;;;;;;;IAiBMC,qBAAM;EAAA;;EAKV,SAAAA,sBAAYT,KAAY,EAAEE,KAAe,EAAEK,OAA6B,EAAE;IAAAhB,eAAA,OAAAkB,qBAAA;IACxE,IAAI,CAACT,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACE,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACK,OAAO,GAAGA,OAAO;EACxB;EAACrB,YAAA,CAAAuB,qBAAA;IAAApB,GAAA;IAAAhB,KAAA,EAKD,SAAAuC,IAAA,EAAe;MACb,IAAMV,KAAK,GAAG,IAAI,CAACA,KAAK;MACxB,IAAI7B,KAAQ,GAAG6B,KAAK,CAAC7B,KAAK;MAC1B,IAAMkC,OAAO,GAAG,IAAI,CAACA,OAAO;MAC5B,IAAI,OAAOA,OAAO,KAAK,UAAU,EAAE;;;QAGjC,IAAMM,EAAE,GAAGzC,oBAAY,CAAiBmC,OAAO,CAAC;QAChDlC,KAAK,GAAGwC,EAAE,CAACX,KAAK,CAAC7B,KAAK,CAAC;MACzB,CAAC,MAAM;;;QAGLA,KAAK,GAAGD,oBAAY,CAAImC,OAAO,CAAC;MAClC;MACA,IAAMO,OAAO,GAAG,CAACC,MAAM,CAACC,EAAE,CAACd,KAAK,CAAC7B,KAAK,EAAEA,KAAK,CAAC;MAC9C6B,KAAK,CAAC7B,KAAK,GAAGA,KAAK;MACnB,OAAOyC,OAAO;IAChB;EAAC;EAAA,OAAAL,qBAAA;AAAA;AAAA,IAGGZ,mBAAI;EAAA;;EAiBR,SAAAA,oBAAA,EAAc;IAAAN,eAAA,OAAAM,mBAAA;IACZ,IAAI,CAACI,IAAI,GAAG,IAAI;IAChB,IAAI,CAACgB,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,WAAW,GAAI,EAAoB;EAC1C;EAAChC,YAAA,CAAAW,mBAAA;IAAAR,GAAA;IAAAhB,KAAA,EAKD,SAAAsC,OAAOH,MAAqB,EAAQ;MAAA,IAAAW,KAAA;MAClC,IAAI,CAACD,WAAW,CAACR,IAAI,CAACF,MAAM,CAAC;MAC7B,IAAI,IAAI,CAACU,WAAW,CAAClC,MAAM,KAAK,CAAC,EAAE;QACjCV,6BAAc,CAAC,YAAY;UACzB,IAAM2C,OAAO,GAAGE,KAAI,CAACF,OAAO;UAC5BjD,iBAAS,CACPiD,OAAO,KAAK,IAAI,EAChB,+CACF,CAAC;UACDE,KAAI,CAACC,MAAM,CAAChD,oBAAY,CAAqB6C,OAAO,CAAC,CAAC;QACxD,CAAC,CAAC;MACJ;IACF;EAAC;IAAA5B,GAAA;IAAAhB,KAAA,EAKD,SAAAgD,OAAOJ,OAA2B,EAAU;MAC1CjD,iBAAS,CACPyB,kCAAmB,KAAK,IAAI,IAAIC,kCAAmB,KAAK,IAAI,EAC5D,kDACF,CAAC;MACD,IAAM4B,UAAU,GAAGL,OAAO,KAAK,IAAI,CAACA,OAAO;MAC3C,IAAI,CAACA,OAAO,GAAGA,OAAO;MACtB,IAAIK,UAAU,EAAE;QACd,IAAI,CAACF,MAAM,CAACH,OAAO,CAAC;MACtB;MAEAjD,iBAAS,CAAC,IAAI,CAACiC,IAAI,KAAK,IAAI,EAAE,8BAA8B,CAAC;MAC7D,IAAMA,IAAW,GAAG7B,oBAAY,CAAQ,IAAI,CAAC6B,IAAI,CAAC;MAClD,IAAMsB,MAAgB,GAAG,EAAE;MAC3B,IAAI,CAACC,UAAU,CAACvB,IAAI,EAAEsB,MAAM,CAAC;;MAE7B,OAAO7C,4BAAa,CAAC6C,MAAM,EAAE,EAAE,CAAC;IAClC;EAAC;IAAAlC,GAAA;IAAAhB,KAAA,EAED,SAAA+C,OAAOH,OAA2B,EAAQ;MACxC,IAAIQ,UAAU,GAAG,IAAI,CAACxB,IAAI,KAAK,IAAI;MACnC,KAAK,IAAMO,MAAM,IAAI,IAAI,CAACU,WAAW,EAAE;QACrCO,UAAU,GAAGjB,MAAM,CAACI,GAAG,CAAC,CAAC,IAAIa,UAAU;MACzC;MACA,IAAI,CAACP,WAAW,GAAI,EAAoB;MACxC,IAAI,CAACO,UAAU,EAAE;QACf;MACF;;;;MAKAjC,iCAAkB,GAAG,IAAI;MACzB,IAAIQ,KAAK,GAAG,IAAI,CAACC,IAAI;MACrB,IAAID,KAAK,KAAK,IAAI,EAAE;QAClBA,KAAK,GAAG,IAAI,CAAC0B,UAAU,CAACT,OAAO,EAAE,IAAI,CAAC;QACtC,IAAI,CAAChB,IAAI,GAAGD,KAAK;MACnB;MACA,OAAOA,KAAK,KAAK,IAAI,EAAE;;QAErB,IAAI2B,MAAa,GAAGvD,oBAAY,CAAQ4B,KAAK,CAAC;QAC9C,IAAI,CAAC4B,WAAW,CAACD,MAAM,CAAC;;QAExB,IAAIA,MAAM,CAACE,KAAK,KAAK,IAAI,EAAE;UACzB7B,KAAK,GAAG2B,MAAM,CAACE,KAAK;QACtB,CAAC,MAAM,IAAIF,MAAM,CAACG,OAAO,KAAK,IAAI,EAAE;UAClC9B,KAAK,GAAG2B,MAAM,CAACG,OAAO;QACxB,CAAC,MAAM;UACL9B,KAAK,GAAG2B,MAAM,CAACI,MAAM;UACrB,OAAO/B,KAAK,KAAK,IAAI,IAAI5B,oBAAY,CAAQ4B,KAAK,CAAC,CAAC8B,OAAO,KAAK,IAAI,EAAE;YACpE9B,KAAK,GAAG5B,oBAAY,CAAQ4B,KAAK,CAAC,CAAC+B,MAAM;UAC3C;UACA,IAAI/B,KAAK,KAAK,IAAI,EAAE;YAClBA,KAAK,GAAG5B,oBAAY,CAAQ4B,KAAK,CAAC,CAAC8B,OAAO;UAC5C;QACF;MACF;MACAtC,iCAAkB,GAAG,IAAI;IAC3B;EAAC;IAAAH,GAAA;IAAAhB,KAAA,EAKD,SAAAmD,WAAWxB,KAAY,EAAEgC,GAAa,EAAQ;MAC5C,QAAQhC,KAAK,CAACb,IAAI,CAAC8C,IAAI;QACrB,KAAK,MAAM;UAAE;YACX,IAAMC,GAAG,GAAG9D,oBAAY,CAAgB4B,KAAK,CAACb,IAAI,CAAC,CAAC+C,GAAG;YACvDF,GAAG,CAACtB,IAAI,CAAC,GAAG,GAAGwB,GAAG,CAAC;YACnB,KAAK,IAAMC,IAAI,IAAIpB,MAAM,CAACqB,OAAO,CAACpC,KAAK,CAACZ,KAAK,CAAC,EAAE;cAAA,IAAAiD,eAAA;cAC9CL,GAAG,CAACtB,IAAI,CACL,IAAGyB,IAAI,CAACA,IAAK,IAAC,CAAAE,eAAA,GAAEC,IAAI,CAACC,SAAS,CAACJ,IAAI,CAAC9D,KAAK,CAAC,YAAAgE,eAAA,GAAI,WAAY,EAC7D,CAAC;YACH;YACAL,GAAG,CAACtB,IAAI,CAAC,GAAG,CAAC;YACb,IAAI,CAAC8B,aAAa,CAACxC,KAAK,EAAEgC,GAAG,CAAC;YAC9BA,GAAG,CAACtB,IAAI,CAAC,IAAI,GAAGwB,GAAG,GAAG,GAAG,CAAC;YAC1B;UACF;QACA,KAAK,MAAM;UAAE;YACX,IAAMO,IAAI,GAAGrE,oBAAY,CAAgB4B,KAAK,CAACb,IAAI,CAAC,CAACsD,IAAI;YACzDT,GAAG,CAACtB,IAAI,CAAC+B,IAAI,CAAC;YACd;UACF;QACA,KAAK,WAAW;UAAE;YAChB,IAAI,CAACD,aAAa,CAACxC,KAAK,EAAEgC,GAAG,CAAC;YAC9B;UACF;MACF;IACF;EAAC;IAAA3C,GAAA;IAAAhB,KAAA,EAED,SAAAmE,cAAcxC,KAAY,EAAEgC,GAAa,EAAQ;MAC/C,IAAIU,OAAqB,GAAG1C,KAAK,CAAC6B,KAAK;MACvC,OAAOa,OAAO,KAAK,IAAI,EAAE;QACvB,IAAI,CAAClB,UAAU,CAACpD,oBAAY,CAAQsE,OAAO,CAAC,EAAEV,GAAG,CAAC;QAClDU,OAAO,GAAGtE,oBAAY,CAAQsE,OAAO,CAAC,CAACZ,OAAO;MAChD;IACF;EAAC;IAAAzC,GAAA;IAAAhB,KAAA,EAMD,SAAAuD,YAAY5B,KAAY,EAAQ;MAC9B,IAAI;QACFP,kCAAmB,GAAGO,KAAK;QAC3BN,kCAAmB,GAAG,IAAI;QAC1B,QAAQM,KAAK,CAACb,IAAI,CAAC8C,IAAI;UACrB,KAAK,WAAW;YAAE;cAChBjE,iBAAS,CACP2B,qCAAsB,CAACX,MAAM,KAAK,CAAC,EACnC,mCACF,CAAC;cACD,IAAMqC,MAA4C,GAChDjD,oBAAY,CAAqB4B,KAAK,CAACb,IAAI,CAAC,CAACwD,SAAS;cACxD,IAAI1B,OAAO,GAAGI,MAAM,CAACrB,KAAK,CAACZ,KAAK,CAAC;cACjC,IAAIwD,cAAsB,GAAG,CAAC;cAC9B,OAAOjD,qCAAsB,CAACX,MAAM,KAAK,CAAC,EAAE;gBAC1C4D,cAAc,EAAE;gBAChB5E,iBAAS,CACP4E,cAAc,GAAG,IAAI,EACrB,oDACF,CAAC;gBACD,IAAItB,UAAU,GAAG,KAAK;gBACtB,KAAK,IAAMd,MAAM,IAAIb,qCAAsB,EAAE;kBAC3C3B,iBAAS,CACPwC,MAAM,CAACR,KAAK,KAAKA,KAAK,EACtB,mFAAmF,GACjF,wEACJ,CAAC;kBACDsB,UAAU,GAAGd,MAAM,CAACI,GAAG,CAAC,CAAC,IAAIU,UAAU;gBACzC;gBACA3B,qCAAsB,CAACX,MAAM,GAAG,CAAC;gBACjC,IAAI,CAACsC,UAAU,EAAE;kBACf;gBACF;gBACAL,OAAO,GAAGI,MAAM,CAACrB,KAAK,CAACZ,KAAK,CAAC;cAC/B;cACAY,KAAK,CAAC6B,KAAK,GAAG,IAAI,CAACgB,cAAc,CAAC7C,KAAK,EAAEA,KAAK,CAAC6B,KAAK,EAAEZ,OAAO,CAAC;cAC9D;YACF;UACA,KAAK,MAAM;UACX,KAAK,MAAM;YAAE;;cAEX;YACF;QACF;MACF,CAAC,SAAS;QACRxB,kCAAmB,GAAG,IAAI;QAC1BC,kCAAmB,GAAG,IAAI;MAC5B;IACF;EAAC;IAAAL,GAAA;IAAAhB,KAAA,EAMD,SAAAqD,WAAWoB,eAA2B,EAAEf,MAAoB,EAAS;MACnE,IAAI/B,KAAY;MAChB,IAAI,OAAO8C,eAAe,KAAK,QAAQ,EAAE;QACvC,IAAM7B,OAAO,GAAG7C,oBAAY,CAAqB0E,eAAe,CAAC;QACjE,IAAI,OAAO7B,OAAO,CAAC9B,IAAI,KAAK,UAAU,EAAE;UACtC,IAAMwD,SAAoB,GAAGvE,oBAAY,CAAY6C,OAAO,CAAC9B,IAAI,CAAC;;;;;UAKlE,IAAMA,IAAe,GAAG,IAAI4D,iCAAkB,CAACJ,SAAS,CAAC;UACzD3C,KAAK,GAAG,IAAIgD,oBAAK,CAAC7D,IAAI,EAAG8B,OAAO,CAAC7B,KAAK,EAAQ6B,OAAO,CAAC5B,GAAG,CAAC;QAC5D,CAAC,MAAM;UACLrB,iBAAS,CACP,OAAOiD,OAAO,CAAC9B,IAAI,KAAK,QAAQ,EAChC,8DAA8D,GAC5Df,oBAAY,CAAS6C,OAAO,CAAC9B,IAAI,CACrC,CAAC;;;;;UAKD,IAAMA,KAAe,GAAG,IAAI8D,4BAAa,CACvC7E,oBAAY,CAAS6C,OAAO,CAAC9B,IAAI,CACnC,CAAC;UACDnB,iBAAS,CACPiD,OAAO,CAAC7B,KAAK,KAAK,IAAI,IAAI,OAAO6B,OAAO,CAAC7B,KAAK,KAAK,QAAQ,EAC3D,0BACF,CAAC;;UAGD,IAAM8D,QAAQ,GAAGjC,OAAO,CAAC7B,KAAK,CAAC8D,QAAQ;UACvC,IAAM9D,OAAK,GAAA2B,MAAA,CAAAoC,MAAA,KAAOlC,OAAO,CAAC7B,KAAK,CAAC;UAChC,OAAOA,OAAK,CAAC8D,QAAQ;UAErBlD,KAAK,GAAG,IAAIgD,oBAAK,CAAC7D,KAAI,EAAEC,OAAK,EAAE6B,OAAO,CAAC5B,GAAG,CAAC;UAC3C,IAAI+D,KAAK,CAACC,OAAO,CAACH,QAAQ,CAAC,EAAE;YAC3B,IAAII,KAAkB,GAAG,IAAI;YAC7B,KAAK,IAAMC,YAAY,IAAInF,oBAAY,CAAQ8E,QAAQ,CAAC,EAAE;cACxD,IAAMrB,KAAK,GAAG,IAAI,CAACH,UAAU,CAC3BtD,oBAAY,CAAamF,YAAY,CAAC,EACtCvD,KACF,CAAC;cACD,IAAIsD,KAAI,KAAK,IAAI,EAAE;gBACjBlF,oBAAY,CAAQkF,KAAI,CAAC,CAACxB,OAAO,GAAGD,KAAK;cAC3C,CAAC,MAAM;;gBAEL7B,KAAK,CAAC6B,KAAK,GAAGA,KAAK;cACrB;cACAyB,KAAI,GAAGzB,KAAK;YACd;UACF,CAAC,MAAM,IAAI,OAAOqB,QAAQ,KAAK,QAAQ,EAAE;YACvC,IAAMrB,MAAK,GAAG,IAAImB,oBAAK,CAAC;cAACf,IAAI,EAAE,MAAM;cAAEQ,IAAI,EAAES;YAAQ,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC;YACjErB,MAAK,CAACE,MAAM,GAAG/B,KAAK;YACpBA,KAAK,CAAC6B,KAAK,GAAGA,MAAK;UACrB,CAAC,MAAM,IAAIqB,QAAQ,IAAI,IAAI,EAAE;YAC3B,IAAMrB,OAAK,GAAG,IAAI,CAACH,UAAU,CAAEwB,QAAQ,EAAQlD,KAAK,CAAC;YACrDA,KAAK,CAAC6B,KAAK,GAAGA,OAAK;UACrB;QACF;MACF,CAAC,MAAM;QACL7D,iBAAS,CAAC,OAAO8E,eAAe,KAAK,QAAQ,EAAE,mBAAmB,CAAC;;;;;QAKnE,IAAM3D,MAAI,GAAG,IAAIqE,4BAAa,CAACpF,oBAAY,CAAS0E,eAAe,CAAC,CAAC;QACrE9C,KAAK,GAAG,IAAIgD,oBAAK,CAAC7D,MAAI,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC;MACnC;MACAa,KAAK,CAAC+B,MAAM,GAAGA,MAAM;MACrB,OAAO/B,KAAK;IACd;EAAC;IAAAX,GAAA;IAAAhB,KAAA,EAOD,SAAAwE,eACEd,MAAa,EACb0B,SAAuB,EACvBxC,OAA2B,EACpB;MACP,IACEwC,SAAS,KAAK,IAAI,IAClBrF,oBAAY,CAAQqF,SAAS,CAAC,CAACtE,IAAI,KAAK8B,OAAO,CAAC9B,IAAI,EACpD;QACA,IAAIsE,UAAgB,GAAGrF,oBAAY,CAAQqF,UAAS,CAAC;;;;QAIrD,IAAIA,UAAS,CAACtE,IAAI,CAAC8C,IAAI,KAAK,MAAM,EAAE;UAClCjE,iBAAS,CACPiD,OAAO,CAAC7B,KAAK,KAAK,IAAI,IAAI,OAAO6B,OAAO,CAAC7B,KAAK,KAAK,QAAQ,EAC3D,0BACF,CAAC;;UAGD,IAAM8D,QAAQ,GAAGjC,OAAO,CAAC7B,KAAK,CAAC8D,QAAQ;UACvC,IAAM9D,OAAK,GAAA2B,MAAA,CAAAoC,MAAA,KAAOlC,OAAO,CAAC7B,KAAK,CAAC;UAChC,OAAOA,OAAK,CAAC8D,QAAQ;UAErBO,UAAS,CAACrE,KAAK,GAAGA,OAAK;UACvB,IAAI,CAACsE,iBAAiB,CAACD,UAAS,EAAGP,QAAc,CAAC;QACpD,CAAC,MAAM,IAAIO,UAAS,CAACtE,IAAI,CAAC8C,IAAI,KAAK,WAAW,EAAE;UAC9CjE,iBAAS,CACPiD,OAAO,CAAC7B,KAAK,KAAK,IAAI,IAAI,OAAO6B,OAAO,CAAC7B,KAAK,KAAK,QAAQ,EAC3D,0BACF,CAAC;UACDqE,UAAS,CAACrE,KAAK,GAAG6B,OAAO,CAAC7B,KAAK;QACjC;QACA,OAAOqE,UAAS;MAClB,CAAC,MAAM;QACL,IAAM5B,KAAK,GAAG,IAAI,CAACH,UAAU,CAACT,OAAO,EAAEc,MAAM,CAAC;QAC9C,OAAOF,KAAK;MACd;IACF;EAAC;IAAAxC,GAAA;IAAAhB,KAAA,EAKD,SAAAqF,kBACE3B,MAAa,EACbmB,QAA0E,EACpE;MACN,IAAMO,SAAuB,GAAG1B,MAAM,CAACF,KAAK;MAC5C,IAAIuB,KAAK,CAACC,OAAO,CAACH,QAAQ,CAAC,EAAE;QAC3B,IAAIS,aAAa,GAAGvF,oBAAY,CAAuB8E,QAAQ,CAAC;;QAEhE,IAAIS,aAAa,CAAC3E,MAAM,KAAK,CAAC,EAAE;UAC9B+C,MAAM,CAACF,KAAK,GAAG,IAAI;QACrB,CAAC,MAAM,IAAI8B,aAAa,CAAC3E,MAAM,KAAK,CAAC,EAAE;UACrC+C,MAAM,CAACF,KAAK,GAAG,IAAI,CAACgB,cAAc,CAACd,MAAM,EAAE0B,SAAS,EAAEE,aAAa,CAAC,CAAC,CAAC,CAAC;UACvEvF,oBAAY,CAAQ2D,MAAM,CAACF,KAAK,CAAC,CAACC,OAAO,GAAG,IAAI;QAClD,CAAC,MAAM;UACL,IAAI,CAAC8B,yBAAyB,CAAC7B,MAAM,EAAE4B,aAAa,CAAC;QACvD;MACF,CAAC,MAAM,IAAI,OAAOT,QAAQ,KAAK,QAAQ,EAAE;QACvC,IACEO,SAAS,KAAK,IAAI,IAClBrF,oBAAY,CAAQqF,SAAS,CAAC,CAACtE,IAAI,CAAC8C,IAAI,KAAK,MAAM,EACnD;UACA,IAAMJ,KAAK,GAAG,IAAImB,oBAAK,CAAC;YAACf,IAAI,EAAE,MAAM;YAAEQ,IAAI,EAAES;UAAQ,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC;UACjEnB,MAAM,CAACF,KAAK,GAAGA,KAAK;QACtB,CAAC,MAAM;UACLzD,oBAAY,CAAgBA,oBAAY,CAAQqF,SAAS,CAAC,CAACtE,IAAI,CAAC,CAACsD,IAAI,GACnErE,oBAAY,CAAS8E,QAAQ,CAAC;QAClC;MACF,CAAC,MAAM,IAAIA,QAAQ,IAAI,IAAI,EAAE;QAC3BnB,MAAM,CAACF,KAAK,GAAG,IAAI,CAACgB,cAAc,CAChCd,MAAM,EACN0B,SAAS,EACTrF,oBAAY,CAAqB8E,QAAQ,CAC3C,CAAC;QACD9E,oBAAY,CAAQ2D,MAAM,CAACF,KAAK,CAAC,CAACC,OAAO,GAAG,IAAI;MAClD,CAAC,MAAM;QACLC,MAAM,CAACF,KAAK,GAAG,IAAI;QACnB,IAAI4B,SAAS,KAAK,IAAI,EAAE;UACtBrF,oBAAY,CAAQqF,SAAS,CAAC,CAAC1B,MAAM,GAAG,IAAI;QAC9C;MACF;IACF;EAAC;IAAA1C,GAAA;IAAAhB,KAAA,EAOD,SAAAuF,0BACE7B,MAAa,EACbmB,QAA8B,EACxB;MACNlF,iBAAS,CACPkF,QAAQ,CAAClE,MAAM,GAAG,CAAC,EACnB,6CACF,CAAC;;MAED,IAAM6E,aAAkB,GAAG,IAAIC,GAAG,CAAC,CAAC;MACpC,IAAIpB,OAAqB,GAAGX,MAAM,CAACF,KAAK;MACxC,OAAOa,OAAO,KAAK,IAAI,EAAE;QACvB,IAAItE,oBAAY,CAAQsE,OAAO,CAAC,CAACrD,GAAG,KAAK,IAAI,EAAE;UAC7CwE,aAAa,CAACE,GAAG,CAAC3F,oBAAY,CAAQsE,OAAO,CAAC,CAACrD,GAAG,EAAEqD,OAAO,CAAC;QAC9D;QACAA,OAAO,GAAGtE,oBAAY,CAAQsE,OAAO,CAAC,CAACZ,OAAO;MAChD;MACA,IAAIwB,IAAkB,GAAG,IAAI,CAAC,C;MAC9B,IAAIU,WAAyB,GAAGjC,MAAM,CAACF,KAAK,CAAC,C;MAC7C,KAAK,IAAM0B,YAAY,IAAIL,QAAQ,EAAE;QAAA,IAAAe,IAAA;QACnC,IAAMC,SAAS,IAAAD,IAAA,GACZV,YAAY,CAAClE,GAAG,IAAI,IAAI,GACrBwE,aAAa,CAACM,GAAG,CAACZ,YAAY,CAAClE,GAAG,CAAC,GACnC,IAAI,YAAA4E,IAAA,GAAKD,WAAW;QAC1B,IAAInC,KAAY;QAChB,IAAIqC,SAAS,IAAI,IAAI,EAAE;UACrBrC,KAAK,GAAG,IAAI,CAACgB,cAAc,CAACd,MAAM,EAAEmC,SAAS,EAAEX,YAAY,CAAC;QAC9D,CAAC,MAAM;UACL1B,KAAK,GAAG,IAAI,CAACH,UAAU,CAAC6B,YAAY,EAAExB,MAAM,CAAC;QAC/C;QACA,IAAIuB,IAAI,KAAK,IAAI,EAAE;UACjBlF,oBAAY,CAAQkF,IAAI,CAAC,CAACxB,OAAO,GAAGD,KAAK;QAC3C,CAAC,MAAM;;UAELE,MAAM,CAACF,KAAK,GAAGA,KAAK;QACtB;QACAyB,IAAI,GAAGzB,KAAK;QACZmC,WAAW,GACTA,WAAW,KAAK,IAAI,GAAG5F,oBAAY,CAAQ4F,WAAW,CAAC,CAAClC,OAAO,GAAG,IAAI;MAC1E;IACF;EAAC;EAAA,OAAAjC,mBAAA;AAAA;;;;;;;;;;;;;;;;;;;;IAyBGuE,wBAAS,gBAAAlF,YAAA,CAEb,SAAAkF,yBAAYnC,IAAY,EAAE;EAAA;;EAAA1C,eAAA,OAAA6E,wBAAA;EACxB,IAAI,CAACnC,IAAI,GAAGA,IAAI;AAClB,CAAC;AAAA,IAGGc,iCAAkB,0BAAAsB,qBAAA;EAAA;;EAAAC,SAAA,CAAAvB,iCAAA,EAAAsB,qBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAzB,iCAAA;EAEtB,SAAAA,kCAAYJ,SAAoB,EAAE;IAAA,IAAA8B,MAAA;IAAAlF,eAAA,OAAAwD,iCAAA;IAChC0B,MAAA,GAAAF,MAAA,CAAAG,IAAA,OAAM,WAAW;IACjBD,MAAA,CAAK9B,SAAS,GAAGA,SAAS;IAAC,OAAA8B,MAAA;EAC7B;EAAC,OAAAvF,YAAA,CAAA6D,iCAAA;AAAA,EAL8BqB,wBAAS;AAAA,IAOpCnB,4BAAa,0BAAA0B,sBAAA;EAAA;;EAAAL,SAAA,CAAArB,4BAAA,EAAA0B,sBAAA;EAAA,IAAAC,OAAA,GAAAJ,YAAA,CAAAvB,4BAAA;EAEjB,SAAAA,6BAAYf,GAAW,EAAE;IAAA,IAAA2C,MAAA;IAAAtF,eAAA,OAAA0D,4BAAA;IACvB4B,MAAA,GAAAD,OAAA,CAAAF,IAAA,OAAM,MAAM;IACZG,MAAA,CAAK3C,GAAG,GAAGA,GAAG;IAAC,OAAA2C,MAAA;EACjB;EAAC,OAAA3F,YAAA,CAAA+D,4BAAA;AAAA,EALyBmB,wBAAS;AAAA,IAO/BZ,4BAAa,0BAAAsB,sBAAA;EAAA;;EAAAR,SAAA,CAAAd,4BAAA,EAAAsB,sBAAA;EAAA,IAAAC,OAAA,GAAAP,YAAA,CAAAhB,4BAAA;EAEjB,SAAAA,6BAAYf,IAAY,EAAE;IAAA,IAAAuC,MAAA;IAAAzF,eAAA,OAAAiE,4BAAA;IACxBwB,MAAA,GAAAD,OAAA,CAAAL,IAAA,OAAM,MAAM;IACZM,MAAA,CAAKvC,IAAI,GAAGA,IAAI;IAAC,OAAAuC,MAAA;EACnB;EAAC,OAAA9F,YAAA,CAAAsE,4BAAA;AAAA,EALyBY,wBAAS;;;;;;;;;IAkB/B/D,oBAAK,gBAAAnB,YAAA,CAKT,SAAAmB,qBAAYhC,KAAQ,EAAE;EAAA;;EAAAkB,eAAA,OAAAc,oBAAA;EACpB,IAAI,CAAChC,KAAK,GAAGA,KAAK;EAElB,IAAI,CAACiC,IAAI,GAAG,IAAI;EAChB,IAAI,CAACgD,IAAI,GAAG,IAAI;AAClB,CAAC;;;;;IAOGN,oBAAK,gBAAA9D,YAAA,CAST,SAAA8D,qBAAY7D,IAAe,EAAEC,KAAY,EAAEC,GAAqB,EAAE;EAAA;;EAAAE,eAAA,OAAAyD,oBAAA;EAChE,IAAI,CAAC7D,IAAI,GAAGA,IAAI;EAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;EAClB,IAAI,CAACC,GAAG,GAAGA,GAAG;EAEd,IAAI,CAAC0C,MAAM,GAAG,IAAI;EAClB,IAAI,CAACF,KAAK,GAAG,IAAI;EACjB,IAAI,CAACC,OAAO,GAAG,IAAI;EACnB,IAAI,CAAC5B,KAAK,GAAG,IAAI;AACnB,CAAC;AAGI,SAAS+E,mBAAaA,CAC3B9F,IAAuB,EACvBC,KAAY,EACZC,GAAqB,EACD;EACpB,QAAQ;;EACR,OAAO;IACLF,IAAI,EAAEA,IAAI;IACVC,KAAK,EAAEA,KAAK;IACZC,GAAG,EAAEA,GAAG;IACRC,GAAG,EAAE;EACP,CAAC;AACH;AAAC;ACrtBD,SAAS4F,oBAAKA,CAAC9F,KAAY,EAAsB;EAC/C,OAfF6F,mBAAA,CAgBI,IAAI,EACJ;IACE/B,QAAQ,EAAE9D,KAAK,CAAC8D;EAClB,CAAC,EACD,IACF,CAAC;AACH;AAEA,SAASiC,0BAAWA,CAACC,MAAa,EAAsB;EACtD,IAAAC,eAAA,GAzBFvF,cAAA,CAyBmD,CAAC,CAAC;IAAAwF,gBAAA,GAAAC,cAAA,CAAAF,eAAA;IAA5CG,KAAK,GAAAF,gBAAA;IAAEG,QAAQ,GAAAH,gBAAA;EAEtB,OA3BFL,mBAAA,CA4BI,KAAK,EACL;IACE/B,QAAQ,EAAE,CA9BhB+B,mBAAA,CAgCUC,oBAAK,EACL;MACEhC,QAAQ,EAAE;IACZ,CAAC,EACD,IACF,CAAC,EACD,SAAS;EAEb,CAAC,EACD,IACF,CAAC;AACH;AAEA,SAASwC,kBAAGA,CAAA,EAAS;EACnB,IAAIC,CAAC,GAAG,CAAC;EACT,KAAK,IAAI7G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6G,CAAC,EAAE,EAAE7G,CAAC,EAAE;IAC1B,IAAImB,IAAI,GAhDZL,gBAAA,CAgDgC,CAAC;IAC7B,IAAIgG,QAAQ,GAAG3F,IAAI,CAACoB,MAAM,CAjD9B4D,mBAAA,CAiDmDE,0BAAW,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;EACxE;EACAU,KAAK,CAACD,QAAQ,CAAC;AACjB;AAEAF,kBAAG,CAAC,CAAC"}