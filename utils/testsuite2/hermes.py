# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

import os
import sys
import tempfile
from asyncio import create_subprocess_exec, subprocess, TimeoutError, wait_for
from dataclasses import dataclass, field
from typing import List, Optional

from preprocess import StrictMode
from progress import TestCaseResult, TestResultCode
from typing_defs import OptNegative, PathT

ES6_ARGS = ["-Xes6-promise", "-Xes6-proxy"]
EXTRA_RUN_ARGS = ["-Xhermes-internal-test-methods"]
USE_MICROTASK_FLAG = ["-Xmicrotask-queue"]

TIMEOUT_COMPILER = 200
TIMEOUT_VM = 200


@dataclass
class ExtraCompileVMArgs(object):
    """
    Extra compiler and vm args that may be necessary for some testsuites.
    """

    compile_args: List[str] = field(default_factory=list)
    vm_args: List[str] = field(default_factory=list)


async def run(
    test_name: str,
    base_file_name: str,
    binary_directory: PathT,
    file_to_run: PathT,
    expected_failure_phase: str,
    disable_handle_san: bool,
    extra_compile_vm_args: Optional[ExtraCompileVMArgs] = None,
) -> Optional[TestCaseResult]:
    # Run the generated bytecode/native code.
    hvm_exe = os.path.join(binary_directory, "hvm")
    args = [file_to_run] + ES6_ARGS + EXTRA_RUN_ARGS + USE_MICROTASK_FLAG
    if extra_compile_vm_args:
        args += extra_compile_vm_args.vm_args
    if disable_handle_san:
        args += ["-gc-sanitize-handles=0"]
    env = {"LC_ALL": "en_US.UTF-8"}
    if sys.platform == "linux":
        env["ICU_DATA"] = binary_directory
    proc = await create_subprocess_exec(
        hvm_exe, *args, env=env, stderr=subprocess.PIPE, stdout=subprocess.PIPE
    )
    stdout, stderr = (None, None)
    try:
        (stdout, stderr) = await wait_for(proc.communicate(), timeout=TIMEOUT_COMPILER)
    except TimeoutError:
        msg = f"FAIL: Execution of binary timed out for {file_to_run}"
        # Kill the subprocess and all its child processes
        proc.kill()
        return TestCaseResult(test_name, TestResultCode.EXECUTE_TIMEOUT, msg)

    output = ""
    if stdout:
        output += f"stdout:\n {stdout.decode('utf-8')}"
    if stderr:
        output += f"stderr:\n {stderr.decode('utf-8')}"

    # Check if the run succeeded
    if proc.returncode:
        if expected_failure_phase == "" or expected_failure_phase != "runtime":
            msg = f"FAIL: Execution of {base_file_name} threw unexpected error"
            return TestCaseResult(test_name, TestResultCode.EXECUTE_FAILED, msg, output)
        else:
            msg = f"PASS: Execution of {base_file_name} threw an error as expected"
            return TestCaseResult(test_name, TestResultCode.TEST_PASSED, msg)
    else:
        if expected_failure_phase != "":
            msg = f"FAIL: Expected execution of {base_file_name} to throw"
            return TestCaseResult(test_name, TestResultCode.EXECUTE_FAILED, msg, output)
    return None


async def compile_and_run(
    test_name: str,
    js_source_files: List[PathT],
    strict_mode: StrictMode,
    binary_directory: PathT,
    negative: OptNegative,
    disable_handle_san: bool,
    extra_compile_vm_args: Optional[ExtraCompileVMArgs] = None,
) -> TestCaseResult:
    """
    Run the generated source files with async subprocess and return the
    result.
    """
    for js_source_file in js_source_files:
        run_vm = True
        base_file_name = os.path.basename(js_source_file)
        file_to_run = f"{js_source_file}.out"
        args = [
            str(js_source_file),
            "-test262",
            "-emit-binary",
            "-fno-static-builtins",
            "-out",
            file_to_run,
        ]

        if extra_compile_vm_args:
            args += extra_compile_vm_args.compile_args

        args.append("-O0")
        if StrictMode.STRICT in strict_mode:
            args.append("-strict")
        else:
            args.append("-non-strict")

        expected_failure_phase = negative["phase"] if negative else ""
        hermesc_exe = os.path.join(binary_directory, "hermesc")
        proc = await create_subprocess_exec(
            hermesc_exe, *args, stderr=subprocess.PIPE, stdout=subprocess.PIPE
        )
        stdout, stderr = (None, None)
        try:
            (stdout, stderr) = await wait_for(
                proc.communicate(), timeout=TIMEOUT_COMPILER
            )
        except TimeoutError:
            msg = f"FAIL: Compilation timed out on {js_source_file}"
            proc.kill()
            return TestCaseResult(test_name, TestResultCode.COMPILE_TIMEOUT, msg)

        output = ""
        if stdout:
            output += f"stdout:\n {stdout.decode('utf-8')}"
        if stderr:
            output += f"stderr:\n {stderr.decode('utf-8')}"

        # Check if the compilation succeeded
        # There is no CalledProcessError in asyncio, so explicitly check the
        # return code.
        if proc.returncode:
            run_vm = False
            if expected_failure_phase != "parse":
                msg = f"FAIL: Compiling failed with command: {args}"
                return TestCaseResult(
                    test_name, TestResultCode.COMPILE_FAILED, msg, output
                )
        else:
            if expected_failure_phase == "parse":
                msg = f"FAIL: Compilation failure expected on {base_file_name} with Hermes"
                return TestCaseResult(
                    test_name, TestResultCode.COMPILE_FAILED, msg, output
                )

        if run_vm:
            # If run failed, return it immediately
            if run_result := await run(
                test_name,
                base_file_name,
                binary_directory,
                file_to_run,
                expected_failure_phase,
                disable_handle_san,
                extra_compile_vm_args,
            ):
                return run_result

    # All files in js_source_files passed
    return TestCaseResult(test_name, TestResultCode.TEST_PASSED)


async def run_hermes_simple(
    hermes_exe: PathT, test_name: str, args: List[str]
) -> TestCaseResult:
    """
    Simply invoke hermes on a JS file with given arguments and return the
    output. This is unlike the above `compile_and_run()` function, which does
    various checking such as compilation failure and runtim failure.
    """
    proc = await create_subprocess_exec(
        hermes_exe,
        *args,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    stdout, stderr = (None, None)
    try:
        (stdout, stderr) = await wait_for(proc.communicate(), timeout=TIMEOUT_COMPILER)
    except TimeoutError:
        proc.kill()
        msg = "FAIL: Hermes timeout"
        details = f"Command: {' '.join(args)}"
        return TestCaseResult(test_name, TestResultCode.COMPILE_TIMEOUT, msg, details)

    if proc.returncode:
        msg = "FAIL: Hermes failed to run"
        details = f"Command: {' '.join(args)}\n"
        details += f"Return code: {proc.returncode}\n"
        details += f"stdout:\n {stdout.decode('utf-8')}"
        details += f"stderr:\n {stderr.decode('utf-8')}"
        return TestCaseResult(test_name, TestResultCode.TEST_FAILED, msg, details)

    # Return the evaluated output (could be JS execution result or dumped AST).
    return TestCaseResult(
        test_name, TestResultCode.TEST_PASSED, "PASS: ", stdout.decode("utf-8").strip()
    )


async def generate_ast(
    test_name: str,
    test_file: PathT,
    binary_path: PathT,
    is_flow: bool,
    transformed: bool,
) -> TestCaseResult:
    """
    Generate the AST for given source file.

    Returns:
    (TestResultCode.TEST_PASSED, JSON) if success.
    (TestResultCode.TEST_FAILED, message) if Hermes failed.
    (TestResultCode.COMPILE_TIMEOUT, message) if Hermes timeout.
    """
    args = []
    if is_flow:
        args.append("-parse-flow")
        args.append("-Xparse-component-syntax")
        args.append("-parse-jsx")
        args.append("-Xinclude-empty-ast-nodes")
    elif "JSX" in test_file:
        args.append("--parse-jsx")
    args.append("-dump-transformed-ast" if transformed else "-dump-ast")
    hermes_exe = os.path.join(binary_path, "hermes")

    # ".source.js" files has the format of "var source = \"...\";", and
    # the value of the 'source' variable should be the input to the parser.
    # So we evaluate the source with Hermes first and then parse the output.
    if test_file.endswith(".source.js"):
        with open(test_file, "rb") as f, tempfile.NamedTemporaryFile() as to_evaluate:
            # append to the original source to print the 'source' variable.
            for line in f:
                to_evaluate.write(line)
            to_evaluate.write(b"print(source);")
            to_evaluate.flush()
            with tempfile.NamedTemporaryFile() as evaluated:
                # evaluate the source to get the actual test input.
                eval_args = [to_evaluate.name]
                result = await run_hermes_simple(hermes_exe, test_name, eval_args)
                if result.code != TestResultCode.TEST_PASSED:
                    return result
                # get rid of the newline added by print().
                evaluated.write(result.output.encode("utf-8"))
                evaluated.flush()
                # run the test through Hermes parser.
                return await run_hermes_simple(
                    hermes_exe, test_name, args + [evaluated.name]
                )
    return await run_hermes_simple(hermes_exe, test_name, args + [test_file])
