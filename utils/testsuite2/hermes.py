# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

import os
import sys
import tempfile
from asyncio import create_subprocess_exec, subprocess, TimeoutError, wait_for
from dataclasses import dataclass, field
from typing import List, Optional

from preprocess import StrictMode
from progress import TestCaseResult, TestResultCode
from typing_defs import OptNegative, PathT

ES6_ARGS = ["-Xes6-promise", "-Xes6-proxy"]
EXTRA_RUN_ARGS = ["-Xhermes-internal-test-methods"]
USE_MICROTASK_FLAG = ["-Xmicrotask-queue"]

TIMEOUT_COMPILER = 200
TIMEOUT_VM = 200


@dataclass
class ExtraCompileVMArgs(object):
    """
    Extra compiler and vm args that may be necessary for some testsuites.
    """

    compile_args: List[str] = field(default_factory=list)
    vm_args: List[str] = field(default_factory=list)


async def run(
    test_name: str,
    base_file_name: str,
    binary_directory: PathT,
    file_to_run: PathT,
    expected_failure_phase: str,
    disable_handle_san: bool,
    extra_compile_vm_args: Optional[ExtraCompileVMArgs] = None,
) -> Optional[TestCaseResult]:
    # Run the generated bytecode/native code.
    hvm_exe = os.path.join(binary_directory, "hvm")
    args = [file_to_run] + ES6_ARGS + EXTRA_RUN_ARGS + USE_MICROTASK_FLAG
    if extra_compile_vm_args:
        args += extra_compile_vm_args.vm_args
    if disable_handle_san:
        args += ["-gc-sanitize-handles=0"]
    env = {"LC_ALL": "en_US.UTF-8"}
    if sys.platform == "linux":
        env["ICU_DATA"] = binary_directory
    proc = await create_subprocess_exec(
        hvm_exe, *args, env=env, stderr=subprocess.PIPE, stdout=subprocess.PIPE
    )
    stdout, stderr = (None, None)
    try:
        (stdout, stderr) = await wait_for(proc.communicate(), timeout=TIMEOUT_COMPILER)
    except TimeoutError:
        msg = f"FAIL: Execution of binary timed out for {file_to_run}"
        # Kill the subprocess and all its child processes
        proc.kill()
        return TestCaseResult(test_name, TestResultCode.EXECUTE_TIMEOUT, msg)

    output = ""
    if stdout:
        output += f"stdout:\n {stdout.decode('utf-8')}"
    if stderr:
        output += f"stderr:\n {stderr.decode('utf-8')}"

    # Check if the run succeeded
    if proc.returncode:
        if expected_failure_phase == "" or expected_failure_phase != "runtime":
            msg = f"FAIL: Execution of {base_file_name} threw unexpected error"
            return TestCaseResult(test_name, TestResultCode.EXECUTE_FAILED, msg, output)
        else:
            msg = f"PASS: Execution of {base_file_name} threw an error as expected"
            return TestCaseResult(test_name, TestResultCode.TEST_PASSED, msg)
    else:
        if expected_failure_phase != "":
            msg = f"FAIL: Expected execution of {base_file_name} to throw"
            return TestCaseResult(test_name, TestResultCode.EXECUTE_FAILED, msg, output)
    return None


async def compile_with_args(
    test_name: str,
    expect_compile_failure: bool,
    hermesc_exe: PathT,
    args: List[str],
) -> Optional[TestCaseResult]:
    """
    Run hermesc with given arguments.

    Returns:
    None, if the compilation is successful, or the compilation throws as
        expected.
    TestCaseResult, if the compilation fails (and it's not expected).
    """

    proc = await create_subprocess_exec(
        hermesc_exe,
        *args,
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE,
    )
    stdout, stderr = (None, None)
    try:
        (stdout, stderr) = await wait_for(proc.communicate(), timeout=TIMEOUT_COMPILER)
    except TimeoutError:
        msg = f"FAIL: Compilation timed out, args: {args}"
        proc.kill()
        return TestCaseResult(test_name, TestResultCode.COMPILE_TIMEOUT, msg)

    output = ""
    if stdout:
        output += f"stdout:\n {stdout.decode('utf-8')}"
    if stderr:
        output += f"stderr:\n {stderr.decode('utf-8')}"

    # Check if the compilation succeeded.
    if proc.returncode:
        # If compilation failed and it's not expected, consider it a failure.
        if not expect_compile_failure:
            msg = f"FAIL: Compilation failed with command: {args}"
            return TestCaseResult(test_name, TestResultCode.COMPILE_FAILED, msg, output)
    else:
        # If the compliation succeeded but a compilation failure is expected,
        # it's also considered a failure.
        if expect_compile_failure:
            msg = "FAIL: Compilation failure expected on with Hermes"
            return TestCaseResult(test_name, TestResultCode.COMPILE_FAILED, msg, output)

    return None


async def compile_and_run_single(
    test_name: str,
    js_source_file: PathT,
    strict_mode: StrictMode,
    binary_directory: PathT,
    negative: OptNegative,
    disable_handle_san: bool,
    extra_compile_vm_args: Optional[ExtraCompileVMArgs] = None,
) -> Optional[TestCaseResult]:
    """
    Compile and run the given source file, return None if it's passed,
    otherwise, return the corresponding TestCaseResult.
    """

    base_file_name = os.path.basename(js_source_file)
    file_to_run = f"{js_source_file}.out"
    args = [
        str(js_source_file),
        "-test262",
        "-emit-binary",
        "-fno-static-builtins",
        "-out",
        file_to_run,
    ]

    if extra_compile_vm_args:
        args += extra_compile_vm_args.compile_args

    if StrictMode.STRICT in strict_mode:
        args.append("-strict")
    else:
        args.append("-non-strict")

    expected_failure_phase = negative["phase"] if negative else ""
    # Whether compilation is expected to fail.
    expect_compile_failure = expected_failure_phase == "parse"
    hermesc_exe = os.path.join(binary_directory, "hermesc")

    # For now, always run without optimization.
    opt_level = "-O0"
    # If compiling failed (not as expected), return the result immediately.
    if unexpected_compile_result := await compile_with_args(
        test_name, expect_compile_failure, hermesc_exe, args + [opt_level]
    ):
        return unexpected_compile_result

    # If compilation failure is not expected, we should have the bytecode
    # ready to run.
    if not expect_compile_failure:
        # If run failed (not as expected), return it immediately
        if run_result := await run(
            test_name,
            base_file_name,
            binary_directory,
            file_to_run,
            expected_failure_phase,
            disable_handle_san,
            extra_compile_vm_args,
        ):
            return run_result
    return None


async def compile_and_run(
    test_name: str,
    js_source_files: List[PathT],
    strict_mode: StrictMode,
    binary_directory: PathT,
    negative: OptNegative,
    disable_handle_san: bool,
    extra_compile_vm_args: Optional[ExtraCompileVMArgs] = None,
) -> TestCaseResult:
    """
    Run the generated source files with async subprocess and return the
    result.
    """

    for js_source_file in js_source_files:
        # If any file is not passed, return the result immediately.
        if unexpected_result := await compile_and_run_single(
            test_name,
            js_source_file,
            strict_mode,
            binary_directory,
            negative,
            disable_handle_san,
            extra_compile_vm_args,
        ):
            return unexpected_result

    # All files in js_source_files passed
    return TestCaseResult(test_name, TestResultCode.TEST_PASSED)


async def run_hermes_simple(
    hermes_exe: PathT, test_name: str, args: List[str]
) -> TestCaseResult:
    """
    Simply invoke hermes on a JS file with given arguments and return the
    output. This is unlike the above `compile_and_run()` function, which does
    various checking such as compilation failure and runtim failure.
    """
    proc = await create_subprocess_exec(
        hermes_exe,
        *args,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    stdout, stderr = (None, None)
    try:
        (stdout, stderr) = await wait_for(proc.communicate(), timeout=TIMEOUT_COMPILER)
    except TimeoutError:
        proc.kill()
        msg = "FAIL: Hermes timeout"
        details = f"Command: {' '.join(args)}"
        return TestCaseResult(test_name, TestResultCode.COMPILE_TIMEOUT, msg, details)

    if proc.returncode:
        msg = "FAIL: Hermes failed to run"
        details = f"Command: {' '.join(args)}\n"
        details += f"Return code: {proc.returncode}\n"
        details += f"stdout:\n {stdout.decode('utf-8')}"
        details += f"stderr:\n {stderr.decode('utf-8')}"
        return TestCaseResult(test_name, TestResultCode.TEST_FAILED, msg, details)

    # Return the evaluated output (could be JS execution result or dumped AST).
    return TestCaseResult(
        test_name, TestResultCode.TEST_PASSED, "PASS: ", stdout.decode("utf-8").strip()
    )


async def generate_ast(
    test_name: str,
    test_file: PathT,
    binary_path: PathT,
    is_flow: bool,
    transformed: bool,
) -> TestCaseResult:
    """
    Generate the AST for given source file.

    Returns:
    (TestResultCode.TEST_PASSED, JSON) if success.
    (TestResultCode.TEST_FAILED, message) if Hermes failed.
    (TestResultCode.COMPILE_TIMEOUT, message) if Hermes timeout.
    """
    args = []
    if is_flow:
        args.append("-parse-flow")
        args.append("-Xparse-component-syntax")
        args.append("-parse-jsx")
        args.append("-Xinclude-empty-ast-nodes")
    elif "JSX" in test_file:
        args.append("--parse-jsx")
    args.append("-dump-transformed-ast" if transformed else "-dump-ast")
    hermes_exe = os.path.join(binary_path, "hermes")

    # ".source.js" files has the format of "var source = \"...\";", and
    # the value of the 'source' variable should be the input to the parser.
    # So we evaluate the source with Hermes first and then parse the output.
    if test_file.endswith(".source.js"):
        with open(test_file, "rb") as f, tempfile.NamedTemporaryFile() as to_evaluate:
            # append to the original source to print the 'source' variable.
            for line in f:
                to_evaluate.write(line)
            to_evaluate.write(b"print(source);")
            to_evaluate.flush()
            with tempfile.NamedTemporaryFile() as evaluated:
                # evaluate the source to get the actual test input.
                eval_args = [to_evaluate.name]
                result = await run_hermes_simple(hermes_exe, test_name, eval_args)
                if result.code != TestResultCode.TEST_PASSED:
                    return result
                # get rid of the newline added by print().
                evaluated.write(result.output.encode("utf-8"))
                evaluated.flush()
                # run the test through Hermes parser.
                return await run_hermes_simple(
                    hermes_exe, test_name, args + [evaluated.name]
                )
    return await run_hermes_simple(hermes_exe, test_name, args + [test_file])
