# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

import os
import sys
from asyncio import create_subprocess_exec, subprocess, TimeoutError, wait_for
from typing import List, Optional

from preprocess import StrictMode
from progress import TestCaseResult, TestResultCode
from typing_defs import OptNegative, PathT

ES6_ARGS = ["-Xes6-promise", "-Xes6-proxy"]
EXTRA_RUN_ARGS = ["-Xhermes-internal-test-methods"]
USE_MICROTASK_FLAG = ["-Xmicrotask-queue"]
EXTRA_COMPILE_FLAGS = ["-fno-static-builtins"]

TIMEOUT_COMPILER = 200
TIMEOUT_VM = 200


async def run(
    test_name: str,
    base_file_name: str,
    binary_directory: PathT,
    file_to_run: PathT,
    expected_failure_phase: str,
    disable_handle_san: bool,
) -> Optional[TestCaseResult]:
    # Run the generated bytecode/native code.
    hvm_exe = os.path.join(binary_directory, "hvm")
    args = [file_to_run] + ES6_ARGS + EXTRA_RUN_ARGS + USE_MICROTASK_FLAG
    if disable_handle_san:
        args += ["-gc-sanitize-handles=0"]
    env = {"LC_ALL": "en_US.UTF-8"}
    if sys.platform == "linux":
        env["ICU_DATA"] = binary_directory
    proc = await create_subprocess_exec(
        hvm_exe, *args, env=env, stderr=subprocess.PIPE, stdout=subprocess.PIPE
    )
    stdout, stderr = (None, None)
    try:
        (stdout, stderr) = await wait_for(proc.communicate(), timeout=TIMEOUT_COMPILER)
    except TimeoutError:
        msg = f"FAIL: Execution of binary timed out for {file_to_run}"
        # Kill the subprocess and all its child processes
        proc.kill()
        return TestCaseResult(test_name, TestResultCode.EXECUTE_TIMEOUT, msg)

    output = ""
    if stdout:
        output += f"stdout:\n {stdout.decode('utf-8')}"
    if stderr:
        output += f"stderr:\n {stderr.decode('utf-8')}"

    # Check if the run succeeded
    if proc.returncode:
        if expected_failure_phase == "" or expected_failure_phase != "runtime":
            msg = f"FAIL: Execution of {base_file_name} threw unexpected error"
            return TestCaseResult(test_name, TestResultCode.EXECUTE_FAILED, msg, output)
        else:
            msg = f"PASS: Execution of {base_file_name} threw an error as expected"
            return TestCaseResult(test_name, TestResultCode.TEST_PASSED, msg)
    else:
        if expected_failure_phase != "":
            msg = f"FAIL: Expected execution of {base_file_name} to throw"
            return TestCaseResult(test_name, TestResultCode.EXECUTE_FAILED, msg, output)
    return None


async def compile_and_run(
    test_name: str,
    js_source_files: List[PathT],
    strict_mode: StrictMode,
    binary_directory: PathT,
    negative: OptNegative,
    disable_handle_san: bool,
) -> TestCaseResult:
    """
    Run the generated source files with async subprocess and return the
    result.
    """
    for js_source_file in js_source_files:
        run_vm = True
        base_file_name = os.path.basename(js_source_file)
        file_to_run = f"{js_source_file}.out"
        args = [
            str(js_source_file),
            "-emit-binary",
            "-out",
            file_to_run,
        ] + EXTRA_COMPILE_FLAGS

        args.append("-O0")
        if StrictMode.STRICT in strict_mode:
            args.append("-strict")
        else:
            args.append("-non-strict")

        expected_failure_phase = negative["phase"] if negative else ""
        hermesc_exe = os.path.join(binary_directory, "hermesc")
        proc = await create_subprocess_exec(
            hermesc_exe, *args, stderr=subprocess.PIPE, stdout=subprocess.PIPE
        )
        stdout, stderr = (None, None)
        try:
            (stdout, stderr) = await wait_for(
                proc.communicate(), timeout=TIMEOUT_COMPILER
            )
        except TimeoutError:
            msg = f"FAIL: Compilation timed out on {js_source_file}"
            proc.kill()
            return TestCaseResult(test_name, TestResultCode.COMPILE_TIMEOUT, msg)

        output = ""
        if stdout:
            output += f"stdout:\n {stdout.decode('utf-8')}"
        if stderr:
            output += f"stderr:\n {stderr.decode('utf-8')}"

        # Check if the compilation succeeded
        # There is no CalledProcessError in asyncio, so explicitly check the
        # return code.
        if proc.returncode:
            run_vm = False
            if expected_failure_phase != "parse":
                msg = f"FAIL: Compiling failed with command: {args}"
                return TestCaseResult(
                    test_name, TestResultCode.COMPILE_FAILED, msg, output
                )
        else:
            if expected_failure_phase == "parse":
                msg = f"FAIL: Compilation failure expected on {base_file_name} with Hermes"
                return TestCaseResult(
                    test_name, TestResultCode.COMPILE_FAILED, msg, output
                )

        if run_vm:
            # If run failed, return it immediately
            if run_result := await run(
                test_name,
                base_file_name,
                binary_directory,
                file_to_run,
                expected_failure_phase,
                disable_handle_san,
            ):
                return run_result

    # All files in js_source_files passed
    return TestCaseResult(test_name, TestResultCode.TEST_PASSED)
